The **Imperative Paradigm** is one of the oldest and most fundamental programming paradigms. It describes **how** a program operates by giving the computer a **sequence of instructions** that change the programâ€™s state.

---

## ğŸ§  What is the Imperative Paradigm?

> Itâ€™s like giving the computer a **step-by-step recipe**:  
> _â€œDo this, then this, now change this variable, loop over that.â€_

It emphasizes:

- **State (variables)** that hold data
- **Statements and instructions** that modify the state
- **Control flow** (if, loops, etc.)

---

## ğŸ§¾ Example in Pseudocode (Imperative Style)

Let's say we want to find the **sum of numbers from 1 to 5**:

```c
int sum = 0;
for (int i = 1; i <= 5; i++) {
    sum = sum + i;
}
printf("%d", sum);  // Output: 15
```

- You're explicitly telling **how** to do the task (initialize `sum`, loop from 1 to 5, keep adding).
- This is the **essence of imperative programming**.

---

## ğŸ–¥ï¸ Examples of Imperative Languages

- **C**
- **C++** (when used in procedural style)
- **Python** (can be imperative)
- **Java**
- **Assembly**

---

## âš™ï¸ Comparison with Declarative Paradigm

| Feature              | Imperative                     | Declarative                                |
| -------------------- | ------------------------------ | ------------------------------------------ |
| Focus                | _How_ to do things             | _What_ to do                               |
| Example (Sum 1 to 5) | Loop and accumulate manually   | Use `sum(1..5)` in SQL or functional style |
| State Change         | Yes (mutable variables)        | Often no (functional/declarative styles)   |
| Readability          | Less concise but more explicit | More concise, harder to debug sometimes    |

---

## ğŸ§ª Real-World Analogy

- **Imperative**: You give your friend step-by-step instructions to make tea (boil water, add tea, stir...).
- **Declarative**: You just say â€œMake me teaâ€ and let them handle the details.

---

## âœ… Advantages

- ğŸ’¡ Clear and intuitive for beginners
- ğŸ§° Full control over the system state and memory
- ğŸš€ Great for performance-critical applications

---

## âŒ Disadvantages

- âŒ Hard to maintain in large projects
- âŒ Code duplication, harder abstraction
- âŒ Side effects can make bugs harder to track

---

Letâ€™s take a real-world example: **Filtering even numbers from a list**  
We'll solve it in both **Imperative** and **Declarative** styles using Python.

---

### ğŸ§± Problem:

> Given a list of numbers, extract only the even numbers.

---

## ğŸ”§ Imperative Style (How to do it step by step)

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
evens = []

for num in numbers:
    if num % 2 == 0:
        evens.append(num)

print(evens)  # Output: [2, 4, 6, 8]
```

ğŸ§  **Explanation**:

- You create a new list `evens`
- Loop through each element
- Check if it's even
- Append it to the new list

---

## ğŸŒ¿ Declarative Style (What you want)

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
evens = list(filter(lambda x: x % 2 == 0, numbers))

print(evens)  # Output: [2, 4, 6, 8]
```

or using list comprehension (still declarative-ish in spirit):

```python
evens = [x for x in numbers if x % 2 == 0]
```

ğŸ§  **Explanation**:

- You tell Python **what** you want: "Filter numbers where the condition is `x % 2 == 0`"
- You donâ€™t manually control the loop or state change

---

## ğŸ” Summary of Difference

| Feature              | Imperative                                       | Declarative                                       |
| -------------------- | ------------------------------------------------ | ------------------------------------------------- |
| Control              | Full manual control (loop, condition, appending) | Outsourced control (filter, expression)           |
| Code Length          | More lines                                       | More concise                                      |
| Readability          | Easier for beginners                             | Cleaner once you understand it                    |
| Use Case Suitability | Great for step-by-step logic                     | Great for data processing, SQL, functional styles |

---
